// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// USB packet memory test
//
// This test performs a simple read/write test of the entire USB packet memory
// from the CPU to check connectivity, addressing, integrity etc. A LFSR-
// generated byte stream is used as the test pattern.
//
// Two methods of access are tested in turn:
// (i)  direct access using the mmio_ routines
// (ii) DIF-based buffer reading/writing

#include <string.h>

//#include "sw/device/lib/dif/dif_pinmux.h"
#include "dif_usbdev.h"
#include "log.h"
#include "print.h"
//#include "sw/device/lib/testing/pinmux_testutils.h"
#include "check.h"
//#include "sw/device/lib/testing/test_framework/ottf_main.h"

//#include "hw/top_earlgrey/sw/autogen/top_earlgrey.h"  // Generated.
#include "dif_usbdev_autogen.h"

#include "usb_testutils_diags.h"

#include "demo_system_regs.h"

//#define USBDEV_BASE_ADDR TOP_EARLGREY_USBDEV_BASE_ADDR
#define USBDEV_BASE_ADDR USBDEV_BASE

//#include "sw/device/lib/dif/usbdev_regs.h"  // Generated.
#ifndef USBDEV_BUFFER_REG_OFFSET
#define USBDEV_BUFFER_REG_OFFSET 0x800u
#endif

// Simple LFSR for 8-bit sequences
#define LFSR_ADVANCE(lfsr) \
  (((lfsr) << 1) ^         \
   ((((lfsr) >> 1) ^ ((lfsr) >> 2) ^ ((lfsr) >> 3) ^ ((lfsr) >> 7)) & 1U))

// Total size of packet buffer memory in bytes
#define USBDEV_PACKET_MEM_SIZE (USBDEV_NUM_BUFFERS * USBDEV_MAX_PACKET_SIZE)

// Verbose repoorting?
// Note: this will make a massive difference to the run time on t-l simulation
//static const bool verbose = false;

// Buffer descriptions
static dif_usbdev_buffer_t buf[USBDEV_NUM_BUFFERS];

// Basic test of packet memory function from the CPU side
static uint8_t testpatt[USBDEV_PACKET_MEM_SIZE];
static uint8_t testcopy[USBDEV_PACKET_MEM_SIZE];

static dif_usbdev_t usbdev;
static dif_usbdev_buffer_pool_t buffer_pool;

//OTTF_DEFINE_TEST_CONFIG();

/* The obvious advantage of using the DIF interface is that we are testing that
   code too, but the disadvantage is that we have to resort to modifying the
   buffer descriptors to perform reads because the buffers are not being used
   in accordance with the expected flow model.
*/

static void mem_dif_write(const dif_usbdev_t *dev, const uint8_t *data,
                          size_t n) {
  const unsigned nbufs =
      (n + USBDEV_MAX_PACKET_SIZE - 1) / USBDEV_MAX_PACKET_SIZE;
  CHECK(nbufs <= USBDEV_NUM_BUFFERS);

  // Allocate all buffers; we're expecting the DIF to return the highest buffer
  // first...
  for (unsigned idx = 0u; idx < nbufs; idx++) {
    CHECK_DIF_OK(dif_usbdev_buffer_request(dev, &buffer_pool, &buf[idx]));
  }

  // Write data to each packet buffer in turn and return the buffers to the pool
  for (unsigned idx = 0u; idx < nbufs; idx++) {
    unsigned id = buf[idx].id;
    size_t bytes_written;
    CHECK_DIF_OK(dif_usbdev_buffer_write(
        dev, &buf[idx], &data[id * USBDEV_MAX_PACKET_SIZE],
        USBDEV_MAX_PACKET_SIZE, &bytes_written));
    CHECK(bytes_written == USBDEV_MAX_PACKET_SIZE);
    CHECK_DIF_OK(dif_usbdev_buffer_return(dev, &buffer_pool, &buf[idx]));
  }
}

static void mem_dif_read(const dif_usbdev_t *dev, uint8_t *data, size_t n) {
  const unsigned nbufs =
      (n + USBDEV_MAX_PACKET_SIZE - 1) / USBDEV_MAX_PACKET_SIZE;
  CHECK(nbufs <= USBDEV_NUM_BUFFERS);

  // Allocate all buffers
  for (unsigned idx = 0u; idx < nbufs; idx++) {
    CHECK_DIF_OK(dif_usbdev_buffer_request(dev, &buffer_pool, &buf[idx]));
  }

  // Read data from each buffer in turn, and in so doing they are returned to
  // the free pool automatically
  for (unsigned idx = 0u; idx < nbufs; idx++) {
    unsigned id = buf[idx].id;
    size_t bytes_written;
    // Note: we need to set the buffer type here to be able to read from it;
    // the other fields are already set appropriately
    buf[idx].type = kDifUsbdevBufferTypeRead;
    CHECK_DIF_OK(dif_usbdev_buffer_read(
        dev, &buffer_pool, &buf[idx], &data[id * USBDEV_MAX_PACKET_SIZE],
        USBDEV_MAX_PACKET_SIZE, &bytes_written));
    CHECK(bytes_written == USBDEV_MAX_PACKET_SIZE);
  }
}

// Perform a read from the usbdev packet memory, optionally using the DIF
// interface
static void mem_read(const dif_usbdev_t *dev, int use_dif, uint8_t *data,
                     size_t n) {
  if (use_dif) {
    mem_dif_read(dev, data, n);
  } else {
    mmio_region_memcpy_from_mmio32(dev->base_addr, USBDEV_BUFFER_REG_OFFSET,
                                   data, n);
  }
}

// Write a block of data to the usbdev packet memory, optionally using the DIF
// interface
static void mem_write(const dif_usbdev_t *dev, int use_dif, const uint8_t *data,
                      size_t n) {
  if (use_dif) {
    mem_dif_write(dev, data, n);
  } else {
    mmio_region_memcpy_to_mmio32(dev->base_addr, USBDEV_BUFFER_REG_OFFSET, data,
                                 n);
  }
}

bool test_mem(void) {
//  LOG_INFO("Running USBDEV Mem Test");
LOG_INFO("UU");

  // Initialize DIF-based access to the packet buffer memory
  CHECK_DIF_OK(
      dif_usbdev_init(mmio_region_from_addr(USBDEV_BASE_ADDR), &usbdev));

  // We need not be concerned with the device configuration but we DO need the
  // buffer pool
  dif_usbdev_config_t config = {
      .have_differential_receiver = dif_bool_to_toggle(false),
      .use_tx_d_se0 = dif_bool_to_toggle(false),
      .single_bit_eop = kDifToggleDisabled,
      .pin_flip = dif_bool_to_toggle(false),
      .clock_sync_signals = kDifToggleEnabled,
  };
  CHECK_DIF_OK(dif_usbdev_configure(&usbdev, &buffer_pool, config));

LOG_INFO("Starting memory test....");

  // Exercise mmio_ routines and then dif_usbdev_ routines in turn
  for (unsigned use_dif = 0u; use_dif <= 1u; use_dif++) {
    // Set up test pattern
    uint8_t lfsr = 0x13u;
    for (unsigned idx = 0u; idx < sizeof(testpatt); idx++) {
      testpatt[idx] = lfsr;
      lfsr = LFSR_ADVANCE(lfsr);
    }

    // Write the generated test pattern to the usbdev packet memory
    mem_write(&usbdev, use_dif, testpatt, sizeof(testpatt));

    // Invalidate the contents of the copy buffer
    memset(testcopy, 0xffu, sizeof(testcopy));

    // Read back a copy of the test pattern from the usbdev packet memory
    mem_read(&usbdev, use_dif, testcopy, USBDEV_PACKET_MEM_SIZE);

    // Check the copy against the original
    CHECK_ARRAYS_EQ(testcopy, testpatt, sizeof(testcopy));

    for (unsigned idx = 0u; idx < sizeof(testpatt); idx++) {
      // Invert the test pattern to ensure every byte is modified
      testcopy[idx] = ~testcopy[idx];
    }

    // Write the modified test pattern to the device memory
    mem_write(&usbdev, use_dif, testcopy, sizeof(testcopy));

    // Invalidate the original test pattern buffer
    memset(testpatt, 0xffu, sizeof(testpatt));

    // Read back the modified test pattern from the device memory
    mem_read(&usbdev, use_dif, testpatt, sizeof(testpatt));

    // Check against the modified test pattern
    CHECK_ARRAYS_EQ(testpatt, testcopy, USBDEV_PACKET_MEM_SIZE);
  }

  LOG_INFO("mem_test passed");

  return true;
}
